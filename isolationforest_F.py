# -*- coding: utf-8 -*-
"""IsolationForest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sjir1LN1tc1z_LHZkZ1P5cbV9lB15lpX
"""

from sklearn.ensemble import IsolationForest
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import kagglehub
import os

madhavmalhotra_unb_cic_iot_dataset_path = kagglehub.dataset_download('madhavmalhotra/unb-cic-iot-dataset')
print('Data source import complete.')

dataset_directory = ' /kaggle/input/unb-cic-iot-dataset/wataiData/csv/CICIoT2023/'

#abrimos la ruta e identificamos la carpeta CICIoT2023
for root, dirs, files in os.walk(madhavmalhotra_unb_cic_iot_dataset_path):
    for dir in dirs:
        if dir == 'CICIoT2023':
            DATASET_DIRECTORY = os.path.join(root, dir)
            break
    else:
        continue
    break

print(f"Directorio del dataset: {DATASET_DIRECTORY}")

data_frames = []

#abrir
for filename in os.listdir(DATASET_DIRECTORY):
    if filename.endswith('.csv'):
        file_path = os.path.join(DATASET_DIRECTORY, filename)

        # Cargar el archivo
        df = pd.read_csv(file_path)

        # Reemplazar valores en la columna 'label': 0 para "BenignTraffic", 1 para el resto
        df['label'] = df['label'].apply(lambda x: 0 if x == 'BenignTraffic' else 1)

        # Mostrar un mensaje de confirmación de carga
        print(f"Archivo cargado: {filename} con {df.shape[0]} muestras")

        # Agregar el dataframe a la lista
        data_frames.append(df)

# Concatenar todos los dataframes en uno solo
if data_frames:  # Verificar que la lista no esté vacía
    data = pd.concat(data_frames, ignore_index=True)

#data = pd.concat(data_frames, ignore_index=True)
# Verificar el resultado
#print("Número de muestras cargadas:", data.shape[0])
#print(data['label'].value_counts())

label_counts = data['label'].value_counts()

# Check the number of unique values in the 'label' column
num_unique_labels = len(label_counts)

# Assign new index labels based on the number of unique values
if num_unique_labels == 1:
    # If only one unique label, assume it's either 'Benigno' or 'Ataque'
    label_counts.index = ['Ataque'] if label_counts.index[0] == 1 else ['Benigno']
elif num_unique_labels == 2:
    # If two unique labels, assign 'Benigno' and 'Ataque'
    label_counts.index = ['Ataque','Benigno']
else:
    # Handle unexpected cases with more than 2 unique labels
    print("Warning: Unexpected number of unique labels in the dataset.")

# Crear la gráfica de barras
plt.figure(figsize=(8, 6))
sns.barplot(x=label_counts.index, y=label_counts.values, palette=['blue', 'red'])
plt.title('Distribución de Tráfico: Ataque vs Benigno ')
plt.xlabel('Tipo de Tráfico')
plt.ylabel('Número de Muestras')
plt.show()

# parámetro de contaminación y aleatoriedad
iso_forest = IsolationForest(contamination=0.05, random_state=42)
iso_forest.fit(data)

# Make predictions
data['anomaly'] = iso_forest.predict(data)

# Replace -1 with 1 for anomalies and 1 with 0 for normal
data['anomaly'] = data['anomaly'].map({-1: 1, 1: 0})

# Display the results
print(data[['label', 'anomaly']])

confusion_matrix = pd.crosstab(data['label'], data['anomaly'], rownames=['Actual'], colnames=['Predicted'])
print(confusion_matrix)

precicion = confusion_matrix.iloc[1,1]/(confusion_matrix.iloc[1,1]+confusion_matrix.iloc[0,1])
recall = confusion_matrix.iloc[1,1]/(confusion_matrix.iloc[1,1]+confusion_matrix.iloc[1,0])
f1_score = 2 * (precicion * recall) / (precicion + recall)

print("Precisión:", precicion)
print("Recall:", recall)
print("F1 Score:", f1_score)